# ğŸ§© é€»è¾‘æ€ç»´ä¸ç®—æ³•é¢˜

> é€‚åˆï¼šæ‰€æœ‰æŠ€æœ¯å²—ä½ã€é”»ç‚¼é€»è¾‘æ€ç»´
> éš¾åº¦ï¼šâ­â­â­â­ (ä¸­çº§-é«˜çº§)
> æ¥æºï¼š[ç™¾åº¦ã€å­—èŠ‚è·³åŠ¨ç­‰å¤§å‚é¢è¯•çœŸé¢˜](https://blog.csdn.net/CCIEHL/article/details/104151990)

## ğŸ“‹ é€»è¾‘æ¨ç†é¢˜

### 1. æ‰¾å‡ºæœ€è½»çš„çƒ

**é—®é¢˜**: 16ä¸ªçƒï¼Œåªæœ‰ä¸€ä¸ªæ›´è½»ï¼Œä¸€ä¸ªå¤©å¹³ï¼Œæ€ä¹ˆä¸‰æ¬¡æ‰¾å‡ºæœ€è½»çš„çƒï¼Ÿ

**è§£ç­”æ€è·¯**:
```
ç¬¬ä¸€æ¬¡ç§°é‡ï¼š
- å°†16ä¸ªçƒåˆ†æˆä¸‰ç»„ï¼š6ã€6ã€4
- ç§°é‡ä¸¤ä¸ª6çƒç»„
- å¦‚æœå¹³è¡¡ï¼Œè½»çƒåœ¨4çƒç»„ä¸­
- å¦‚æœä¸å¹³è¡¡ï¼Œè½»çƒåœ¨è¾ƒè½»çš„6çƒç»„ä¸­

ç¬¬äºŒæ¬¡ç§°é‡ï¼š
- æƒ…å†µ1ï¼šå¦‚æœè½»çƒåœ¨4çƒç»„
  - åˆ†æˆ2ã€2ç§°é‡
  - æ‰¾å‡ºè¾ƒè½»çš„2çƒç»„
- æƒ…å†µ2ï¼šå¦‚æœè½»çƒåœ¨6çƒç»„
  - åˆ†æˆ2ã€2ã€2
  - ç§°é‡ä¸¤ä¸ª2çƒç»„
  - ç¡®å®šè½»çƒæ‰€åœ¨çš„2çƒç»„

ç¬¬ä¸‰æ¬¡ç§°é‡ï¼š
- å°†å‰©ä½™çš„2ä¸ªçƒç§°é‡
- æ‰¾å‡ºè¾ƒè½»çš„çƒ

ä¼˜åŒ–æ–¹æ¡ˆï¼ˆæ›´é€šç”¨ï¼‰ï¼š
- ä½¿ç”¨ä¸‰åˆ†æ³•
- æ¯æ¬¡å°†çƒåˆ†æˆå°½å¯èƒ½ç›¸ç­‰çš„ä¸‰ç»„
- é€šè¿‡ç§°é‡æ’é™¤2/3çš„å¯èƒ½æ€§
```

**å…³é”®ç‚¹**:
- åˆ©ç”¨å¤©å¹³çš„ä¸‰ç§çŠ¶æ€ï¼šå·¦é‡ã€å³é‡ã€å¹³è¡¡
- æ¯æ¬¡ç§°é‡æœ€å¤§åŒ–ä¿¡æ¯è·å–
- åˆ†ç»„ç­–ç•¥çš„ä¼˜åŒ–

---

### 2. çƒ§ç»³è®¡æ—¶é—®é¢˜

**é—®é¢˜**: çƒ§ä¸€æ ¹ä¸å‡åŒ€çš„ç»³å­ï¼Œä»å¤´çƒ§åˆ°å°¾æ˜¯è¦1ä¸ªå°æ—¶ã€‚ç°åœ¨æœ‰è‹¥å¹²æ¡æè´¨ç›¸åŒçš„ç»³å­ï¼Œé—®å¦‚ä½•ç”¨çƒ§ç»³çš„æ–¹æ³•æ¥è®¡æ—¶ä¸€ä¸ªå°æ—¶15åˆ†é’Ÿï¼Ÿ

**è§£ç­”æ€è·¯**:
```
åŸºç¡€çŸ¥è¯†ï¼š
- ä¸€æ ¹ç»³å­çƒ§å®Œéœ€è¦1å°æ—¶
- åŒæ—¶ç‚¹ç‡ƒä¸¤ç«¯ï¼Œçƒ§å®Œéœ€è¦30åˆ†é’Ÿ
- ç»³å­ä¸å‡åŒ€ï¼Œä½†æ€»æ—¶é—´å›ºå®š

è§£å†³æ–¹æ¡ˆï¼š
1. å‡†å¤‡ä¸¤æ ¹ç»³å­Aå’ŒB
2. T=0æ—¶åˆ»ï¼š
   - ç»³å­Aï¼šåŒæ—¶ç‚¹ç‡ƒä¸¤ç«¯
   - ç»³å­Bï¼šåªç‚¹ç‡ƒä¸€ç«¯
3. T=30åˆ†é’Ÿï¼ˆAçƒ§å®Œï¼‰ï¼š
   - ç»³å­Bï¼šæ­¤æ—¶è¿˜å‰©30åˆ†é’Ÿ
   - ç«‹å³ç‚¹ç‡ƒBçš„å¦ä¸€ç«¯
4. T=45åˆ†é’Ÿï¼ˆBçƒ§å®Œï¼‰ï¼š
   - å·²ç»è¿‡äº†30+15=45åˆ†é’Ÿ
5. å†ç‚¹ç‡ƒä¸€æ ¹æ–°ç»³å­Cï¼š
   - åªç‚¹ç‡ƒä¸€ç«¯
6. T=1å°æ—¶45åˆ†é’Ÿï¼ˆCçƒ§å®Œï¼‰ï¼š
   - æ€»è®¡æ—¶ï¼š45åˆ†é’Ÿ + 60åˆ†é’Ÿ = 1å°æ—¶15åˆ†é’Ÿ

æ›´ç®€å•çš„æ–¹æ¡ˆï¼š
1. åŒæ—¶å¼€å§‹ï¼š
   - ç»³å­Aï¼šç‚¹ç‡ƒä¸€ç«¯ï¼ˆ60åˆ†é’Ÿï¼‰
   - ç»³å­Bï¼šç‚¹ç‡ƒä¸¤ç«¯ï¼ˆ30åˆ†é’Ÿï¼‰
2. Bçƒ§å®Œåï¼ˆ30åˆ†é’Ÿï¼‰ï¼š
   - ç»³å­Cï¼šç‚¹ç‡ƒä¸¤ç«¯ï¼ˆ15åˆ†é’Ÿï¼‰
   - Aç»§ç»­çƒ§
3. Cçƒ§å®Œåï¼ˆ45åˆ†é’Ÿï¼‰ï¼š
   - Aç»§ç»­çƒ§
4. Açƒ§å®Œï¼ˆ75åˆ†é’Ÿï¼‰ï¼š
   - æ€»æ—¶é—´ï¼š1å°æ—¶15åˆ†é’Ÿ
```

**æ‰©å±•æ€è€ƒ**:
- å¦‚ä½•è®¡æ—¶45åˆ†é’Ÿï¼Ÿ
- å¦‚ä½•è®¡æ—¶ä»»æ„æ—¶é—´ï¼Ÿ
- æœ€å°‘éœ€è¦å‡ æ ¹ç»³å­ï¼Ÿ

---

## ğŸ“‹ ç®—æ³•ç¼–ç¨‹é¢˜

### 3. B+æ ‘å®ç°

**é—®é¢˜**: é€‰ä¸€ä¸ªå–œæ¬¢çš„è¯­è¨€ï¼Œå†™B+æ ‘

**Goè¯­è¨€å®ç°**:
```go
package main

type BPlusNode struct {
    isLeaf   bool
    keys     []int
    children []*BPlusNode
    next     *BPlusNode  // å¶å­èŠ‚ç‚¹é“¾è¡¨
    parent   *BPlusNode
}

type BPlusTree struct {
    root  *BPlusNode
    order int  // B+æ ‘çš„é˜¶æ•°
}

func NewBPlusTree(order int) *BPlusTree {
    return &BPlusTree{
        root:  &BPlusNode{isLeaf: true},
        order: order,
    }
}

// æ’å…¥æ“ä½œ
func (t *BPlusTree) Insert(key int) {
    root := t.root
    
    // å¦‚æœæ ¹èŠ‚ç‚¹æ»¡äº†ï¼Œéœ€è¦åˆ†è£‚
    if len(root.keys) >= t.order-1 {
        newRoot := &BPlusNode{isLeaf: false}
        newRoot.children = append(newRoot.children, root)
        t.splitChild(newRoot, 0)
        t.root = newRoot
        root = newRoot
    }
    
    t.insertNonFull(root, key)
}

// åœ¨éæ»¡èŠ‚ç‚¹æ’å…¥
func (t *BPlusTree) insertNonFull(node *BPlusNode, key int) {
    i := len(node.keys) - 1
    
    if node.isLeaf {
        // å¶å­èŠ‚ç‚¹ç›´æ¥æ’å…¥
        node.keys = append(node.keys, 0)
        for i >= 0 && node.keys[i] > key {
            node.keys[i+1] = node.keys[i]
            i--
        }
        node.keys[i+1] = key
    } else {
        // éå¶å­èŠ‚ç‚¹ï¼Œæ‰¾åˆ°åˆé€‚çš„å­èŠ‚ç‚¹
        for i >= 0 && node.keys[i] > key {
            i--
        }
        i++
        
        if len(node.children[i].keys) >= t.order-1 {
            t.splitChild(node, i)
            if key > node.keys[i] {
                i++
            }
        }
        t.insertNonFull(node.children[i], key)
    }
}

// åˆ†è£‚å­èŠ‚ç‚¹
func (t *BPlusTree) splitChild(parent *BPlusNode, index int) {
    fullNode := parent.children[index]
    newNode := &BPlusNode{isLeaf: fullNode.isLeaf}
    
    mid := t.order / 2
    
    // åˆ†é…é”®å€¼
    newNode.keys = append(newNode.keys, fullNode.keys[mid:]...)
    fullNode.keys = fullNode.keys[:mid]
    
    // å¦‚æœä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œåˆ†é…å­èŠ‚ç‚¹
    if !fullNode.isLeaf {
        newNode.children = append(newNode.children, fullNode.children[mid:]...)
        fullNode.children = fullNode.children[:mid]
    }
    
    // æ›´æ–°çˆ¶èŠ‚ç‚¹
    parent.keys = append(parent.keys[:index], 
        append([]int{fullNode.keys[mid-1]}, parent.keys[index:]...)...)
    parent.children = append(parent.children[:index+1], 
        append([]*BPlusNode{newNode}, parent.children[index+1:]...)...)
    
    // å¦‚æœæ˜¯å¶å­èŠ‚ç‚¹ï¼Œç»´æŠ¤é“¾è¡¨
    if fullNode.isLeaf {
        newNode.next = fullNode.next
        fullNode.next = newNode
    }
}

// æŸ¥æ‰¾æ“ä½œ
func (t *BPlusTree) Search(key int) bool {
    return t.searchNode(t.root, key)
}

func (t *BPlusTree) searchNode(node *BPlusNode, key int) bool {
    i := 0
    for i < len(node.keys) && key > node.keys[i] {
        i++
    }
    
    if i < len(node.keys) && key == node.keys[i] {
        if node.isLeaf {
            return true
        }
    }
    
    if node.isLeaf {
        return false
    }
    
    return t.searchNode(node.children[i], key)
}
```

**Pythonå®ç°**:
```python
class BPlusNode:
    def __init__(self, is_leaf=True):
        self.keys = []
        self.children = []
        self.is_leaf = is_leaf
        self.next = None  # å¶å­èŠ‚ç‚¹é“¾è¡¨
        
class BPlusTree:
    def __init__(self, order=3):
        self.root = BPlusNode()
        self.order = order
    
    def insert(self, key):
        root = self.root
        if len(root.keys) >= self.order - 1:
            new_root = BPlusNode(is_leaf=False)
            new_root.children.append(root)
            self._split_child(new_root, 0)
            self.root = new_root
            root = new_root
        self._insert_non_full(root, key)
    
    def search(self, key):
        return self._search_node(self.root, key)
```

---

### 4. å¿«é€Ÿæ’åºå®ç°

**é—®é¢˜**: å†™ä¸€ä¸ªå¿«æ’

**Goè¯­è¨€å®ç°**:
```go
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    
    pivot := arr[len(arr)/2]
    left := []int{}
    right := []int{}
    equal := []int{}
    
    for _, v := range arr {
        if v < pivot {
            left = append(left, v)
        } else if v > pivot {
            right = append(right, v)
        } else {
            equal = append(equal, v)
        }
    }
    
    left = quickSort(left)
    right = quickSort(right)
    
    return append(append(left, equal...), right...)
}

// åŸåœ°å¿«æ’ï¼ˆæ›´é«˜æ•ˆï¼‰
func quickSortInPlace(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSortInPlace(arr, low, pi-1)
        quickSortInPlace(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}
```

---

### 5. å•é“¾è¡¨å®ç°

**é—®é¢˜**: Pythonå®ç°ä¸€ä¸ªå•é“¾è¡¨

**Pythonå®ç°**:
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedList:
    def __init__(self):
        self.head = None
        self.size = 0
    
    def add_first(self, val):
        """åœ¨é“¾è¡¨å¤´éƒ¨æ·»åŠ èŠ‚ç‚¹"""
        new_node = ListNode(val)
        new_node.next = self.head
        self.head = new_node
        self.size += 1
    
    def add_last(self, val):
        """åœ¨é“¾è¡¨å°¾éƒ¨æ·»åŠ èŠ‚ç‚¹"""
        new_node = ListNode(val)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        self.size += 1
    
    def remove_first(self):
        """åˆ é™¤å¤´èŠ‚ç‚¹"""
        if not self.head:
            return None
        val = self.head.val
        self.head = self.head.next
        self.size -= 1
        return val
    
    def remove(self, val):
        """åˆ é™¤æŒ‡å®šå€¼çš„èŠ‚ç‚¹"""
        if not self.head:
            return False
        
        if self.head.val == val:
            self.head = self.head.next
            self.size -= 1
            return True
        
        current = self.head
        while current.next:
            if current.next.val == val:
                current.next = current.next.next
                self.size -= 1
                return True
            current = current.next
        return False
    
    def reverse(self):
        """åè½¬é“¾è¡¨"""
        prev = None
        current = self.head
        
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        
        self.head = prev
    
    def find_middle(self):
        """æ‰¾åˆ°é“¾è¡¨ä¸­é—´èŠ‚ç‚¹ï¼ˆå¿«æ…¢æŒ‡é’ˆï¼‰"""
        if not self.head:
            return None
        
        slow = fast = self.head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        return slow.val
    
    def has_cycle(self):
        """æ£€æµ‹é“¾è¡¨æ˜¯å¦æœ‰ç¯"""
        if not self.head:
            return False
        
        slow = fast = self.head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        
        return False
    
    def display(self):
        """æ‰“å°é“¾è¡¨"""
        result = []
        current = self.head
        while current:
            result.append(str(current.val))
            current = current.next
        return " -> ".join(result)
```

---

### 6. è£…é¥°å™¨å®ç°é‡è¯•åŠŸèƒ½

**é—®é¢˜**: Pythonè£…é¥°å™¨å®ç°é‡è¯•åŠŸèƒ½ä»£ç å®ç°

**Pythonå®ç°**:
```python
import time
import functools
from typing import Callable, Any, Optional, Type, Tuple

def retry(
    max_attempts: int = 3,
    delay: float = 1.0,
    backoff: float = 2.0,
    exceptions: Tuple[Type[Exception], ...] = (Exception,),
    on_retry: Optional[Callable] = None
):
    """
    é‡è¯•è£…é¥°å™¨
    
    Args:
        max_attempts: æœ€å¤§é‡è¯•æ¬¡æ•°
        delay: åˆå§‹å»¶è¿Ÿæ—¶é—´ï¼ˆç§’ï¼‰
        backoff: å»¶è¿Ÿæ—¶é—´çš„å€æ•°ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
        exceptions: éœ€è¦æ•è·çš„å¼‚å¸¸ç±»å‹
        on_retry: é‡è¯•æ—¶çš„å›è°ƒå‡½æ•°
    """
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            attempt = 1
            current_delay = delay
            
            while attempt <= max_attempts:
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    if attempt == max_attempts:
                        print(f"æœ€ç»ˆå¤±è´¥: {func.__name__} åœ¨ {max_attempts} æ¬¡å°è¯•åå¤±è´¥")
                        raise
                    
                    if on_retry:
                        on_retry(func.__name__, attempt, e)
                    else:
                        print(f"é‡è¯• {attempt}/{max_attempts}: {func.__name__} å¤±è´¥: {e}")
                    
                    time.sleep(current_delay)
                    current_delay *= backoff
                    attempt += 1
            
            return None
        
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@retry(max_attempts=3, delay=1, backoff=2)
def unstable_api_call():
    """æ¨¡æ‹Ÿä¸ç¨³å®šçš„APIè°ƒç”¨"""
    import random
    if random.random() < 0.7:  # 70%æ¦‚ç‡å¤±è´¥
        raise ConnectionError("APIè¿æ¥å¤±è´¥")
    return "æˆåŠŸ"

# æ›´é«˜çº§çš„é‡è¯•è£…é¥°å™¨
class RetryWithContext:
    """å¸¦ä¸Šä¸‹æ–‡çš„é‡è¯•è£…é¥°å™¨"""
    
    def __init__(
        self,
        max_attempts: int = 3,
        delay: float = 1.0,
        backoff: float = 2.0,
        max_delay: float = 60.0,
        exceptions: Tuple[Type[Exception], ...] = (Exception,),
        should_retry: Optional[Callable[[Exception], bool]] = None
    ):
        self.max_attempts = max_attempts
        self.delay = delay
        self.backoff = backoff
        self.max_delay = max_delay
        self.exceptions = exceptions
        self.should_retry = should_retry
    
    def __call__(self, func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            attempt = 1
            current_delay = self.delay
            last_exception = None
            
            while attempt <= self.max_attempts:
                try:
                    result = func(*args, **kwargs)
                    if attempt > 1:
                        print(f"æˆåŠŸ: {func.__name__} åœ¨ç¬¬ {attempt} æ¬¡å°è¯•æˆåŠŸ")
                    return result
                    
                except self.exceptions as e:
                    last_exception = e
                    
                    # æ£€æŸ¥æ˜¯å¦åº”è¯¥é‡è¯•
                    if self.should_retry and not self.should_retry(e):
                        raise
                    
                    if attempt == self.max_attempts:
                        raise
                    
                    # è®°å½•é‡è¯•ä¿¡æ¯
                    print(f"é‡è¯• {attempt}/{self.max_attempts}: "
                          f"{func.__name__} å¤±è´¥: {e.__class__.__name__}: {e}")
                    
                    # ç­‰å¾…å¹¶å¢åŠ å»¶è¿Ÿ
                    time.sleep(current_delay)
                    current_delay = min(current_delay * self.backoff, self.max_delay)
                    attempt += 1
            
            raise last_exception
        
        return wrapper

# ä½¿ç”¨ç¤ºä¾‹
def should_retry_on_rate_limit(e: Exception) -> bool:
    """åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•"""
    if isinstance(e, ValueError) and "rate limit" in str(e).lower():
        return True
    return isinstance(e, (ConnectionError, TimeoutError))

@RetryWithContext(
    max_attempts=5,
    delay=1,
    backoff=2,
    max_delay=30,
    exceptions=(ConnectionError, TimeoutError, ValueError),
    should_retry=should_retry_on_rate_limit
)
def api_request(url: str):
    """å¸¦é‡è¯•çš„APIè¯·æ±‚"""
    # å®é™…çš„APIè¯·æ±‚é€»è¾‘
    pass

# å¼‚æ­¥é‡è¯•è£…é¥°å™¨
import asyncio

def async_retry(max_attempts: int = 3, delay: float = 1.0):
    """å¼‚æ­¥é‡è¯•è£…é¥°å™¨"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(1, max_attempts + 1):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts:
                        raise
                    print(f"å¼‚æ­¥é‡è¯• {attempt}/{max_attempts}: {e}")
                    await asyncio.sleep(delay * attempt)
            return None
        return wrapper
    return decorator
```

---

## ğŸ“‹ æ•…éšœæ’æŸ¥é¢˜

### 7. ç”¨æˆ·æ— æ³•è®¿é—®é—®é¢˜

**é—®é¢˜**: ä¸€ä¸ªç”¨æˆ·ä¸èƒ½è®¿é—®ï¼Œè§£å†³æ€è·¯

**æ’æŸ¥æµç¨‹**:
```yaml
1. æ”¶é›†ä¿¡æ¯:
   - ç”¨æˆ·ä½ç½®ï¼ˆåœ°åŸŸã€ç½‘ç»œç¯å¢ƒï¼‰
   - è®¿é—®æ—¶é—´
   - é”™è¯¯ä¿¡æ¯/ç°è±¡
   - å½±å“èŒƒå›´ï¼ˆä¸ªåˆ«ç”¨æˆ·è¿˜æ˜¯æ‰¹é‡ï¼‰

2. ç½‘ç»œå±‚æ’æŸ¥:
   - pingæµ‹è¯•è¿é€šæ€§
   - tracerouteæŸ¥çœ‹è·¯ç”±è·¯å¾„
   - nslookup/digæ£€æŸ¥DNSè§£æ
   - telnetæµ‹è¯•ç«¯å£è¿é€šæ€§

3. åº”ç”¨å±‚æ’æŸ¥:
   - æ£€æŸ¥æœåŠ¡çŠ¶æ€
   - æŸ¥çœ‹åº”ç”¨æ—¥å¿—
   - æ£€æŸ¥è´Ÿè½½å‡è¡¡å™¨
   - éªŒè¯SSLè¯ä¹¦

4. ç”¨æˆ·ä¾§æ’æŸ¥:
   - æµè§ˆå™¨ç¼“å­˜/Cookie
   - ä»£ç†è®¾ç½®
   - é˜²ç«å¢™/å®‰å…¨è½¯ä»¶
   - DNSè®¾ç½®

5. å…·ä½“å‘½ä»¤:
```bash
# ç½‘ç»œè¿é€šæ€§
ping -c 10 example.com
traceroute example.com
mtr example.com

# DNSæ£€æŸ¥
nslookup example.com
dig example.com @8.8.8.8

# ç«¯å£æµ‹è¯•
telnet example.com 443
nc -zv example.com 443

# HTTPæµ‹è¯•
curl -v https://example.com
curl -I https://example.com

# è¯ä¹¦æ£€æŸ¥
openssl s_client -connect example.com:443
```

---

### 8. ç”¨æˆ·åŠ«æŒæ£€æµ‹

**é—®é¢˜**: æ€ä¹ˆè¯æ˜ä¸€ä¸ªç”¨æˆ·è¢«åŠ«æŒäº†ï¼Ÿ

**æ£€æµ‹æ–¹æ³•**:
```yaml
1. DNSåŠ«æŒæ£€æµ‹:
   - å¯¹æ¯”ä¸åŒDNSæœåŠ¡å™¨è§£æç»“æœ
   - æ£€æŸ¥è§£æIPæ˜¯å¦åœ¨é¢„æœŸèŒƒå›´
   - ç›‘æ§DNS TTLå¼‚å¸¸

2. HTTPåŠ«æŒæ£€æµ‹:
   - æ£€æŸ¥å“åº”å†…å®¹æ˜¯å¦è¢«ç¯¡æ”¹
   - éªŒè¯å“åº”å¤´æ˜¯å¦æ­£ç¡®
   - æ£€æµ‹æ˜¯å¦æœ‰æ³¨å…¥çš„JS/å¹¿å‘Š

3. è¯ä¹¦åŠ«æŒæ£€æµ‹:
   - éªŒè¯SSLè¯ä¹¦é“¾
   - æ£€æŸ¥è¯ä¹¦æŒ‡çº¹
   - å¯¹æ¯”è¯ä¹¦é¢å‘æœºæ„

4. æ£€æµ‹è„šæœ¬:
```bash
#!/bin/bash
# DNSåŠ«æŒæ£€æµ‹
domain="example.com"
expected_ip="1.2.3.4"

# æµ‹è¯•å¤šä¸ªDNS
for dns in 8.8.8.8 114.114.114.114 1.1.1.1; do
    result=$(dig @$dns $domain +short)
    if [ "$result" != "$expected_ip" ]; then
        echo "DNSåŠ«æŒæ£€æµ‹: $dns è¿”å› $result"
    fi
done

# HTTPåŠ«æŒæ£€æµ‹
response=$(curl -s https://example.com)
if echo "$response" | grep -q "injected_content"; then
    echo "æ£€æµ‹åˆ°å†…å®¹æ³¨å…¥"
fi

# è¯ä¹¦æ£€æµ‹
cert_fingerprint=$(echo | openssl s_client -connect example.com:443 2>/dev/null | \
    openssl x509 -fingerprint -noout)
expected_fingerprint="SHA1 Fingerprint=XX:XX:XX..."
if [ "$cert_fingerprint" != "$expected_fingerprint" ]; then
    echo "è¯ä¹¦å¯èƒ½è¢«æ›¿æ¢"
fi
```

---

### 9. ç³»ç»Ÿç›‘æ§å·¥å…·å¯¹æ¯”

**é—®é¢˜**: iotop iostatåŒºåˆ«

**è¯¦ç»†å¯¹æ¯”**:
```yaml
iostat:
- åŠŸèƒ½ï¼šæ˜¾ç¤ºCPUå’Œç£ç›˜I/Oç»Ÿè®¡ä¿¡æ¯
- çº§åˆ«ï¼šç³»ç»Ÿçº§åˆ«ç»Ÿè®¡
- è¾“å‡ºï¼šå¹³å‡å€¼å’Œç´¯è®¡å€¼
- ç”¨é€”ï¼šæ•´ä½“I/Oæ€§èƒ½åˆ†æ

iotop:
- åŠŸèƒ½ï¼šæ˜¾ç¤ºè¿›ç¨‹çº§åˆ«çš„I/Oä½¿ç”¨æƒ…å†µ
- çº§åˆ«ï¼šè¿›ç¨‹çº§åˆ«å®æ—¶ç›‘æ§
- è¾“å‡ºï¼šæ¯ä¸ªè¿›ç¨‹çš„è¯»å†™é€Ÿç‡
- ç”¨é€”ï¼šæ‰¾å‡ºI/Oå¯†é›†å‹è¿›ç¨‹

ä½¿ç”¨ç¤ºä¾‹:
```bash
# iostat - ç³»ç»Ÿçº§I/Oç»Ÿè®¡
iostat -x 1 10  # æ¯ç§’åˆ·æ–°ï¼Œå…±10æ¬¡
iostat -d -p sda  # æ˜¾ç¤ºsdaç£ç›˜è¯¦ç»†ä¿¡æ¯

# iotop - è¿›ç¨‹çº§I/Oç›‘æ§
iotop -o  # åªæ˜¾ç¤ºæœ‰I/Oçš„è¿›ç¨‹
iotop -P  # æ˜¾ç¤ºè¿›ç¨‹è€Œéçº¿ç¨‹
iotop -a  # æ˜¾ç¤ºç´¯è®¡I/O

# å…¶ä»–ç›¸å…³å·¥å…·
dstat  # ç»¼åˆç›‘æ§å·¥å…·
atop   # é«˜çº§ç³»ç»Ÿç›‘æ§
htop   # å¢å¼ºç‰ˆtop
vmstat # è™šæ‹Ÿå†…å­˜ç»Ÿè®¡
```

---

### 10. æ­å»ºHTTP DNS

**é—®é¢˜**: å¦‚ä½•è‡ªå·±æ­å»ºä¸€ä¸ªhttpdns

**å®ç°æ–¹æ¡ˆ**:
```go
// HTTP DNSæœåŠ¡å™¨å®ç°
package main

import (
    "encoding/json"
    "fmt"
    "net"
    "net/http"
    "sync"
    "time"
)

type DNSCache struct {
    sync.RWMutex
    records map[string]*DNSRecord
}

type DNSRecord struct {
    IPs       []string  `json:"ips"`
    TTL       int       `json:"ttl"`
    UpdatedAt time.Time `json:"updated_at"`
}

type HTTPDNSServer struct {
    cache     *DNSCache
    upstream  string
}

func NewHTTPDNSServer() *HTTPDNSServer {
    return &HTTPDNSServer{
        cache: &DNSCache{
            records: make(map[string]*DNSRecord),
        },
        upstream: "8.8.8.8:53",
    }
}

// HTTPæ¥å£å¤„ç†
func (s *HTTPDNSServer) HandleResolve(w http.ResponseWriter, r *http.Request) {
    domain := r.URL.Query().Get("domain")
    if domain == "" {
        http.Error(w, "domain parameter required", http.StatusBadRequest)
        return
    }
    
    // æŸ¥è¯¢ç¼“å­˜
    record := s.getFromCache(domain)
    if record == nil {
        // ç¼“å­˜æœªå‘½ä¸­ï¼Œè¿›è¡ŒDNSæŸ¥è¯¢
        ips, err := s.resolve(domain)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        
        record = &DNSRecord{
            IPs:       ips,
            TTL:       300,
            UpdatedAt: time.Now(),
        }
        
        s.updateCache(domain, record)
    }
    
    // è¿”å›JSONç»“æœ
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(record)
}

// DNSè§£æ
func (s *HTTPDNSServer) resolve(domain string) ([]string, error) {
    ips, err := net.LookupHost(domain)
    if err != nil {
        return nil, err
    }
    return ips, nil
}

// ç¼“å­˜ç®¡ç†
func (s *HTTPDNSServer) getFromCache(domain string) *DNSRecord {
    s.cache.RLock()
    defer s.cache.RUnlock()
    
    record, exists := s.cache.records[domain]
    if !exists {
        return nil
    }
    
    // æ£€æŸ¥TTL
    if time.Since(record.UpdatedAt).Seconds() > float64(record.TTL) {
        return nil
    }
    
    return record
}

func (s *HTTPDNSServer) updateCache(domain string, record *DNSRecord) {
    s.cache.Lock()
    defer s.cache.Unlock()
    s.cache.records[domain] = record
}

// å¯åŠ¨æœåŠ¡å™¨
func main() {
    server := NewHTTPDNSServer()
    
    http.HandleFunc("/resolve", server.HandleResolve)
    http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    })
    
    fmt.Println("HTTP DNS Server starting on :8080")
    http.ListenAndServe(":8080", nil)
}

// å®¢æˆ·ç«¯ä½¿ç”¨ç¤ºä¾‹
func queryHTTPDNS(domain string) ([]string, error) {
    resp, err := http.Get(fmt.Sprintf("http://httpdns.example.com:8080/resolve?domain=%s", domain))
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var record DNSRecord
    if err := json.NewDecoder(resp.Body).Decode(&record); err != nil {
        return nil, err
    }
    
    return record.IPs, nil
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [CSDNåŸæ–‡ï¼šå­—èŠ‚è·³åŠ¨èš‚èšé‡‘æœç™¾åº¦SREç¤¾æ‹›é¢ç»](https://blog.csdn.net/CCIEHL/article/details/104151990)
- [LeetCodeç®—æ³•ç»ƒä¹ ](https://leetcode.cn/)
- [B+æ ‘åŸç†è¯¦è§£](https://en.wikipedia.org/wiki/B%2B_tree)

## ğŸ“ å¤ä¹ è¦ç‚¹

1. **é€»è¾‘æ€ç»´é¢˜é‡åœ¨æ€è·¯**ï¼Œä¸è¦æ€¥äºæ±‚è§£
2. **ç®—æ³•é¢˜è¦æŒæ¡å¤šç§è¯­è¨€å®ç°**
3. **è£…é¥°å™¨ç­‰é«˜çº§ç‰¹æ€§è¦ç†è§£åŸç†**
4. **æ•…éšœæ’æŸ¥è¦æœ‰ç³»ç»ŸåŒ–çš„æ–¹æ³•è®º**
5. **å·¥å…·ä½¿ç”¨è¦äº†è§£åŸç†å’Œé€‚ç”¨åœºæ™¯**
